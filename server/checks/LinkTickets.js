import Check from './Check';
import {logger} from '../../common/debug';
import * as EVENTS from '../model/GithubEvents';

const info = logger('linktickets', 'info');
const error = logger('linktickets', 'error');
const ACTIONS = ['opened', 'edited', 'reopened', 'synchronize'];

export default class LinkTickets extends Check {

  static TYPE = 'linktickets';
  static NAME = 'Link tickets';
  static HOOK_EVENTS = [EVENTS.PULL_REQUEST];

  /**
   * @param {GithubService} github
   */
  constructor(github) {
    super();
    this.github = github;
  }

  /**
   * Parse ticket numbers from commit messages
   * @param pattern {string} Configured regular expression to match the ticket id
   * @param commits {Array<Object>} List of commit objects
   * @returns {Array<string>}
   */
  getTicketNumbers(pattern, commits) {
    let regex = new RegExp(pattern, 'm');
    // Collect ticket numbers from all commits
    return commits.reduce((tickets, ref) => {
      let match = ref.commit.message.match(regex);
      let ticket = match ? match.length > 1 ? match[1] : match[0] : null;
      // Add unique ticket to list
      if (ticket && tickets.indexOf(ticket) === -1) {
        tickets.push(ticket);
      }
      return tickets;
    }, []);
  }

  /**
   * Generate the new body for a pull request containing links to related tickets
   * @param pr {Object} Pr from webhook payload
   * @param repo {Object} Pr related repository
   * @param tickets {Array<string>} List of ticket id's related to this pr
   * @param url {string} Base url to ticket tracker (Jira, Github, ...)
   * @param headline {string} Headline for ticket link enumeration
   * @returns {string}
   */
  generatePullRequestBody(pr, repo, tickets, url, headline) {
    if (!tickets.length) {
      return pr.body;
    }
    // This regex matches the content generated by this function
    let escapedHeadline = headline.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    let regex = new RegExp(escapedHeadline + '\n?(https?:\/\/.*\n?)*');
    // Create base url with trailing slash and replaced placeholders
    let baseUrl = url.replace('${owner}', repo.owner.login)
                     .replace('${repo}', repo.name);
    // Get the body without ticket links
    let body = (pr.body + '\n' || "").replace(regex, '');
    // Generate body with links to ticket
    body += headline + '\n';
    for (let ticket of tickets) {
      body += baseUrl.replace('${id}', ticket) + '\n';
    }

    return body;
  }

  /**
   * Execute the hook
   * @param config {Object} Zappr config object
   * @param hookPayload {Object} Payload send via github webhook
   * @param token {string} OAuth access token to call Github API
   */
  async execute(config, hookPayload, token) {
    const {linkticket: {url, pattern, headline}} = config;
    const {action, pull_request: pr, repository: repo} = hookPayload;

    if (ACTIONS.indexOf(action) === -1 || !pr || 'open' !== pr.state) {
      info(`${repo.full_name}#${pr.number}: Nothing to do, action was "${action}" with state "${pr.state}".`);
      return
    }
    // Get commits for current pr to fetch ticket numbers
    const commits = await this.github.fetchPullRequestCommits(repo.owner.login, repo.name, pr.number, token);
    // Get tickets mentioned in commits related to this pr
    const tickets = this.getTicketNumbers(pattern, commits);
    // Update the pull request body with new text containing links to tickets
    const body = this.generatePullRequestBody(pr, repo, tickets, url, headline);
    // Update pr with new body
    const newPullRequest = await this.github.updatePullRequest(repo.owner.login, repo.name, pr.number, {body}, token);
    if (newPullRequest) {
      info(`${repo.full_name}#${pr.number}: Added ${tickets.length} ticket links to pr`);
      // Updating the hookPayload for further checks
      hookPayload.pull_request = newPullRequest;
    }
    else {
      error(`${repo.full_name}#${pr.number}: Couldn\'t add ticket links to pr`)
    }
    return hookPayload;
  }
}
